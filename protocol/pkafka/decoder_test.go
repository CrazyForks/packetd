// Copyright 2025 The packetd Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pkafka

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/packetd/packetd/common"
	"github.com/packetd/packetd/common/socket"
	"github.com/packetd/packetd/internal/zerocopy"
	"github.com/packetd/packetd/protocol/role"
)

func TestDecodeRequest(t *testing.T) {
	tests := []struct {
		name    string
		input   [][]byte
		request *Request
	}{
		{
			name: "MetadataRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x1B,
					0x00, 0x03,
					0x00, 0x00,
					0x00, 0x00,
					0x00, 0x01, 0x00, 0x06, 'c', 'l', 'i', 'e', 'n', 't',
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x05, 't', 'o', 'p', 'i', 'c',
				},
			},
			request: &Request{
				Size: 31,
				Packet: &Packet{
					API:           "Metadata",
					APIVersion:    0,
					CorrelationID: 1,
					ClientID:      "client",
					Topic:         "topic",
				},
			},
		},
		{
			name: "ProduceRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x3A,
					0x00, 0x00,
					0x00, 0x03,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x08, 'p', 'r', 'o', 'd', 'u', 'c', 'e', 'r',
					0x00, 0x08, 't', 'x', '-', '1', '2', '3', '4', '5',
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x64,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x06, 't', 'o', 'p', 'i', 'c', '1',
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x1A,
				},
			},
			request: &Request{
				Size: 62,
				Packet: &Packet{
					API:           "Produce",
					APIVersion:    3,
					CorrelationID: 2,
					ClientID:      "producer",
					Topic:         "topic1",
				},
			},
		},
		{
			name: "ComplexProduceRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x7A,
					0x00, 0x00,
					0x00, 0x07,
					0x00, 0x00, 0x00, 0x0A,
					0x00, 0x0A, 'p', 'r', 'o', 'd', 'u', 'c', 'e', 'r', '-', '1',
					0x00, 0x0C, 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '1',
					0x00, 0x01,
					0x00, 0x00, 0x00, 0x64,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x06, 't', 'o', 'p', 'i', 'c', '1',
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x1E,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x12,
					0x02,
				},
				{
					0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x1E,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x12,
					0x02,
					0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
				},
			},
			request: &Request{
				Size: 126,
				Packet: &Packet{
					API:           "Produce",
					APIVersion:    7,
					CorrelationID: 10,
					ClientID:      "producer-1",
					Topic:         "topic1",
				},
			},
		},

		{
			name: "FetchRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x39,
					0x00, 0x01,
					0x00, 0x07,
					0x00, 0x00,
					0x00, 0x03, 0x00, 0x07, 'c', 'o', 'n', 's', 'u', 'm', 'e',
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x64,
					0x00, 0x00, 0x10, 0x00,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x06, 't', 'o', 'p', 'i', 'c', '1',
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
			},
			request: &Request{
				Size: 61,
				Packet: &Packet{
					API:           "Fetch",
					APIVersion:    7,
					CorrelationID: 3,
					ClientID:      "consume",
				},
			},
		},
		{
			name: "ListOffsetsRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x31,
					0x00, 0x02,
					0x00, 0x02,
					0x00, 0x00, 0x00, 0x04,
					0x00, 0x06, 'a', 'd', 'm', 'i', 'n', '1',
					0x00, 0x00, 0x00, 0x01,
					0x01,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x06, 't', 'o', 'p', 'i', 'c', '1',
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x00,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				},
			},
			request: &Request{
				Size: 53,
				Packet: &Packet{
					API:           "ListOffsets",
					APIVersion:    2,
					CorrelationID: 4,
					ClientID:      "admin1",
					Topic:         "topic1",
				},
			},
		},
		{
			name: "CreateTopicsRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x41,
					0x00, 0x13,
					0x00, 0x02,
					0x00, 0x00,
					0x00, 0x05, 0x00, 0x06, 'a', 'd', 'm', 'i', 'n', '2',
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x06, 'n', 'e', 'w', 't', 'o', 'p', '1',
					0x00, 0x00, 0x00, 0x03,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x0D, 'c', 'l', 'e', 'a', 'n', 'u', 'p', '.', 'p', 'o', 'l', 'i', 'c', 'y',
					0x00, 0x06, 'd', 'e', 'l', 'e', 't', 'e',
				},
			},
			request: &Request{
				Size: 69,
				Packet: &Packet{
					API:           "CreateTopics",
					APIVersion:    2,
					CorrelationID: 5,
					ClientID:      "admin2",
					Topic:         "newtop",
				},
			},
		},
		{
			name: "JoinGroupRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x40,
					0x00, 0x0B,
					0x00, 0x04,
					0x00, 0x00, 0x00, 0x06,
					0x00, 0x09, 'c', 'o', 'n', 's', 'u', 'm', 'e', 'r', '1',
					0x00, 0x07, 'g', 'r', 'o', 'u', 'p', 'I', 'd',
					0x00, 0x00, 0x00, 0x3C,
					0x00, 0x00, 0x00, 0x0A,
					0x00, 0x08, 'm', 'e', 'm', 'b', 'e', 'r', 'I', 'd',
					0x00, 0x0B, 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'T', 'y', 'p', 'e',
					0x00, 0x00, 0x00, 0x02,
				},
			},
			request: &Request{
				Size: 68,
				Packet: &Packet{
					API:           "JoinGroup",
					APIVersion:    4,
					CorrelationID: 6,
					ClientID:      "consumer1",
					GroupID:       "groupId",
				},
			},
		},
		{
			name: "OffsetCommitRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x32,
					0x00, 0x08,
					0x00, 0x05,
					0x00, 0x00, 0x00, 0x07,
					0x00, 0x09, 'c', 'o', 'n', 's', 'u', 'm', 'e', 'r', '2',
					0x00, 0x07, 'g', 'r', 'o', 'u', 'p', 'I', 'd',
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x08, 'm', 'e', 'm', 'b', 'e', 'r', 'I', 'd',
					0x00, 0x00, 0x00, 0x0A,
					0x00, 0x00, 0x00, 0x01,
				},
			},
			request: &Request{
				Size: 54,
				Packet: &Packet{
					API:           "OffsetCommit",
					APIVersion:    5,
					CorrelationID: 7,
					ClientID:      "consumer2",
					GroupID:       "groupId",
				},
			},
		},
		{
			name: "DescribeConfigsRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x2f,
					0x00, 0x20,
					0x00, 0x02,
					0x00, 0x00, 0x00, 0x08,
					0x00, 0x06, 'a', 'd', 'm', 'i', 'n', '3',
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x02,
					0x00, 0x00, 0x00, 0x01,
					0x31,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x01,
					0x00, 0x00, 0x00, 0x06,
					't', 'o', 'p', 'i', 'c', '1',
					0x00, 0x00, 0x00, 0x00,
				},
			},
			request: &Request{
				Size: 51,
				Packet: &Packet{
					API:           "DescribeConfigs",
					APIVersion:    2,
					CorrelationID: 8,
					ClientID:      "admin3",
				},
			},
		},
		{
			name: "SaslHandshakeRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x18,
					0x00, 0x11,
					0x00, 0x01,
					0x00, 0x00, 0x00, 0x09,
					0x00, 0x06, 'c', 'l', 'i', 'e', 'n', 't', '2',
					0x00, 0x04, 'P', 'L', 'A', 'I', 'N',
				},
			},
			request: &Request{
				Size: 28,
				Packet: &Packet{
					API:           "SaslHandshake",
					APIVersion:    1,
					CorrelationID: 9,
					ClientID:      "client",
				},
			},
		},
		{
			name: "CreateAclsRequest",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x51,
					0x00, 0x1E,
					0x00, 0x02,
					0x00, 0x00, 0x00, 0x0B,
					0x00, 0x07, 'a', 'd', 'm', 'i', 'n', '-', '1',
					0x00, 0x00, 0x00, 0x02,
					0x02,
					0x00, 0x06, 't', 'o', 'p', 'i', 'c', '1',
					0x03,
					0x00, 0x05, 'u', 's', 'e', 'r', '1',
					0x00, 0x0A, '1', '2', '7', '.', '0', '.', '0', '.', '1',
					0x02,
					0x03,
					0x03,
					0x00, 0x07, 'g', 'r', 'o', 'u', 'p', '1',
					0x03,
					0x00, 0x05, 'u', 's', 'e', 'r', '2',
					0x00, 0x09, 'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't',
					0x03,
					0x03,
				},
			},
			request: &Request{
				Size: 85,
				Packet: &Packet{
					API:           "CreateAcls",
					APIVersion:    2,
					CorrelationID: 11,
					ClientID:      "admin-1",
				},
			},
		},
	}

	var st socket.Tuple
	var t0 time.Time
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := NewDecoder(st, 0, common.NewOptions())
			var err error
			var objs []*role.Object
			for _, input := range tt.input {
				objs, err = d.Decode(zerocopy.NewBuffer(input), t0)
			}
			assert.NoError(t, err)

			obj, ok := objs[0].Obj.(*Request)
			assert.True(t, ok)
			assert.Equal(t, tt.request.Size, obj.Size)
			assert.Equal(t, tt.request.Packet, obj.Packet)
		})
	}
}

func TestDecodeResponse(t *testing.T) {
	tests := []struct {
		name     string
		input    [][]byte
		response *Response
	}{
		{
			name: "ComplexMetadataResponse",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x96,
					0x00, 0x00, 0x00, 0x0A,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x09, 'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't',
					0x00, 0x00, 0x23, 0x84,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x0D, 'k', 'a', 'f', 'k', 'a', '-', 'b', 'r', 'o', 'k', 'e', 'r',
					0x00, 0x00, 0x23, 0x84,
					0x00, 0x08, 'r', 'a', 'c', 'k', '-', '1', '0', '1',
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00,
					0x00, 0x06, 't', 'o', 'p', 'i', 'c', '1',
					0x01,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
				},
			},
			response: &Response{
				Size:      154,
				ErrorCode: "NoError",
			},
		},
		{
			name: "ProduceResponseWithErrors",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x4F,
					0x00, 0x00, 0x00, 0x0B,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x06, 't', 'o', 'p', 'i', 'c', '1',
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x01,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x06, 't', 'o', 'p', 'i', 'c', '2',
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x03,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
				},
			},
			response: &Response{
				Size:      83,
				ErrorCode: "NoError",
			},
		},
		{
			name: "ComplexFetchResponse",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x80,
					0x00, 0x00, 0x00, 0x0C,
					0x00, 0x01, 0x00, 0x02,
					0x00, 0x06, 't', 'o', 'p', 'i', 'c', '1',
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x1E,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x12,
					0x02,
				},
				{
					0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00,
				},
			},
			response: &Response{
				Size:      132,
				ErrorCode: "OffsetOutOfRange",
			},
		},
		{
			name: "CreateAclsResponse",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x18,
					0x00, 0x00, 0x00, 0x0D,
					0x00, 0x00, 0x00, 0x64,
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x1D,
					0x00, 0x00, 0x00, 0x02,
				},
			},
			response: &Response{
				Size:      28,
				ErrorCode: "NoError",
			},
		},
		{
			name: "ComplexJoinGroupResponse",
			input: [][]byte{
				{
					0x00, 0x00, 0x00, 0x5A,
					0x00, 0x00, 0x00, 0x0E,
					0x00, 0x00, 0x00, 0x00,
					0x00, 0x00,
					0x00, 0x00, 0x00, 0x01,
					0x00, 0x08, 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l',
					0x00, 0x08, 'l', 'e', 'a', 'd', 'e', 'r', '1', '2',
					0x00, 0x08, 'm', 'e', 'm', 'b', 'e', 'r', '1', '2',
					0x00, 0x00, 0x00, 0x02,
					0x00, 0x08, 'm', 'e', 'm', 'b', 'e', 'r', '1', '2',
					0x00, 0x00, 0x00, 0x0C,
					0x00, 0x08, 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l',
					0x00, 0x08, 'm', 'e', 'm', 'b', 'e', 'r', '3', '4',
					0x00, 0x00, 0x00, 0x0C,
					0x00, 0x08, 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l',
				},
			},
			response: &Response{
				Size:      94,
				ErrorCode: "NoError",
			},
		},
	}

	var st socket.Tuple
	var t0 time.Time
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := NewDecoder(st, 9092, common.NewOptions())
			var err error
			var objs []*role.Object
			for _, input := range tt.input {
				objs, err = d.Decode(zerocopy.NewBuffer(input), t0)
			}
			assert.NoError(t, err)

			obj, ok := objs[0].Obj.(*Response)
			assert.True(t, ok)
			assert.Equal(t, tt.response.Size, obj.Size)
			assert.Equal(t, tt.response.ErrorCode, obj.ErrorCode)
		})
	}
}

func TestDecodeFailed(t *testing.T) {
	tests := []struct {
		name  string
		input []byte
		isErr bool
	}{
		{
			name:  "EmptyInput",
			input: []byte{},
			isErr: false,
		},
		{
			name:  "InvalidLengthTooShort",
			input: []byte{0x00, 0x00},
			isErr: false,
		},
		{
			name: "InvalidAPIVersion",
			input: []byte{
				0x00, 0x00, 0x00, 0x08,
				0x00, 0x01,
				0xFF, 0xFF,
			},
			isErr: false,
		},
		{
			name: "InvalidCorrelationID",
			input: []byte{
				0x00, 0x00, 0x00, 0x06,
				0x00, 0x02,
				0x00, 0x01,
			},
			isErr: false,
		},
		{
			name: "InvalidClientIDLength",
			input: []byte{
				0x00, 0x00, 0x00, 0x08,
				0x00, 0x03,
				0x00, 0x01,
				0x00, 0x00, 0x00, 0x01,
				0xFF, 0xFF,
			},
			isErr: true,
		},
		{
			name: "InvalidTopicNameLength",
			input: []byte{
				0x00, 0x00, 0x00, 0x10,
				0x00, 0x00,
				0x00, 0x02,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x03, 'f', 'o', 'o',
				0x00, 0x01,
				0x00, 0x00, 0x00, 0x64,
				0x00, 0x00, 0x00, 0x01,
				0xFF, 0xFF,
			},
			isErr: true,
		},
		{
			name: "InvalidPartitionCount",
			input: []byte{
				0x00, 0x00, 0x00, 0x14,
				0x00, 0x00,
				0x00, 0x02,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x03, 'f', 'o', 'o',
				0x00, 0x01,
				0x00, 0x00, 0x00, 0x64,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x03, 'b', 'a', 'r',
			},
			isErr: true,
		},
		{
			name: "InvalidMessageSetSize",
			input: []byte{
				0x00, 0x00, 0x00, 0x1C,
				0x00, 0x00,
				0x00, 0x02,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x03, 'f', 'o', 'o',
				0x00, 0x01,
				0x00, 0x00, 0x00, 0x64,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x03, 'b', 'a', 'r',
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x00, 0x00, 0x00,
			},
			isErr: true,
		},
		{
			name: "InvalidRecordBatch",
			input: []byte{
				0x00, 0x00, 0x00, 0x20,
				0x00, 0x00,
				0x00, 0x02,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x03, 'f', 'o', 'o',
				0x00, 0x01,
				0x00, 0x00, 0x00, 0x64,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x03, 'b', 'a', 'r',
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x08,
				0x00, 0x00, 0x00, 0x00,
			},
			isErr: true,
		},
		{
			name: "InvalidFetchRequest",
			input: []byte{
				0x00, 0x00, 0x00, 0x14,
				0x00, 0x01,
				0x00, 0x07,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x03, 'f', 'o', 'o',
				0x00, 0x00, 0x00, 0x00,
			},
			isErr: true,
		},
		{
			name: "InvalidJoinGroupRequest",
			input: []byte{
				0x00, 0x00, 0x00, 0x10,
				0x00, 0x0B,
				0x00, 0x04,
				0x00, 0x00, 0x00, 0x01,
				0x00, 0x03, 'f', 'o', 'o',
			},
			isErr: false,
		},
	}

	var st socket.Tuple
	var t0 time.Time
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := NewDecoder(st, 0, common.NewOptions())
			objs, err := d.Decode(zerocopy.NewBuffer(tt.input), t0)
			if tt.isErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			assert.Nil(t, objs)
		})
	}
}

func TestDecodeStringType(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		nullable bool
		s        string
		offset   int
	}{
		{
			name:     "EmptyInput",
			input:    []byte{},
			nullable: false,
		},
		{
			name:     "LengthTooShort",
			input:    []byte{0x00},
			nullable: false,
		},
		{
			name:     "NullStringWithNullableTrue",
			input:    []byte{0xFF, 0xFF},
			nullable: true,
			s:        "",
			offset:   0,
		},
		{
			name:     "NullStringWithNullableFalse",
			input:    []byte{0xFF, 0xFF},
			nullable: false,
		},
		{
			name:     "ValidString",
			input:    []byte{0x00, 0x05, 'h', 'e', 'l', 'l', 'o'},
			nullable: false,
			s:        "hello",
			offset:   7,
		},
		{
			name:     "StringLengthExceedsInput",
			input:    []byte{0x00, 0x05, 'h', 'e', 'l'},
			nullable: false,
		},
		{
			name:     "ZeroLengthString",
			input:    []byte{0x00, 0x00},
			nullable: false,
			s:        "",
			offset:   2,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s, offset, _ := decodeStringType(tt.input, tt.nullable)
			assert.Equal(t, tt.s, s)
			assert.Equal(t, tt.offset, offset)
		})
	}
}

func TestDecodeCompactStringType(t *testing.T) {
	tests := []struct {
		name   string
		input  []byte
		s      string
		offset int
	}{
		{
			name:  "EmptyInput",
			input: []byte{},
		},
		{
			name:  "InvalidVarint",
			input: []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
		},
		{
			name:   "ZeroLengthString",
			input:  []byte{0x00},
			s:      "",
			offset: 1,
		},
		{
			name:   "ValidString",
			input:  []byte{0x05, 'h', 'e', 'l', 'l', 'o'},
			s:      "hell",
			offset: 5,
		},
		{
			name:  "StringLengthExceedsInput",
			input: []byte{0x05, 'h', 'e', 'l'},
		},
		{
			name:   "InvalidUTF8",
			input:  []byte{0x03, 0xFF, 0xFE, 0xFD},
			offset: 3,
		},
		{
			name:   "SingleByteString",
			input:  []byte{0x02, 'A'},
			s:      "A",
			offset: 2,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s, offset, _ := decodeCompactStringType(tt.input)
			assert.Equal(t, tt.s, s)
			assert.Equal(t, tt.offset, offset)
		})
	}
}
